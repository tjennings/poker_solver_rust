# Per-Flop Postflop Exploitability Early Stopping

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace avg positive regret with exploitability as the convergence metric and early-stopping criterion in the per-flop bucketed and MCCFR CFR solvers.

**Architecture:** Add a best-response tree traversal that reuses `eval_with_avg_strategy`'s structure but maximizes at the BR player's decision nodes. Compute exploitability = sum of BR values for both players across all bucket pairs. Wire into `solve_one_flop()` and `mccfr_solve_one_flop()` loops, replacing `avg_positive_regret_flat()`. Update `FlopStage`, `FlopSolveResult`, and config naming.

**Tech Stack:** Rust, rayon (parallelism), serde (config)

---

### Task 1: Add `best_response_value()` to `postflop_bucketed.rs`

**Files:**
- Modify: `crates/core/src/preflop/postflop_bucketed.rs` (after `eval_with_avg_strategy` ~line 664)

**Step 1: Write a test for `best_response_value`**

Add to `mod tests` at the bottom of `postflop_bucketed.rs`:

```rust
#[timed_test]
fn best_response_value_is_non_negative() {
    // In any zero-sum game, the best-response value for one player
    // against the opponent's avg strategy should be >= the game value.
    // With uniform equity (0.5), values should be near 0.
    let config = PostflopModelConfig::fast();
    let tree = PostflopTree::build_with_spr(&config, 3.5).unwrap();
    let streets = annotate_streets(&tree);
    let layout = PostflopLayout::build(&tree, &streets, 5, 5, 5);
    let buf_size = layout.total_size;

    let eq = BucketEquity {
        equity: vec![vec![0.5; 5]; 5],
        num_buckets: 5,
    };
    let f2t = identity_transition(5);
    let t2r = identity_transition(5);
    let solve_eq = SolveEquity {
        flop: &eq, turn: &eq, river: &eq,
        flop_to_turn: &f2t, turn_to_river: &t2r,
    };

    // Run a few CFR iterations to get a non-trivial strategy_sum
    let result = solve_one_flop(
        &tree, &layout, &solve_eq,
        5, buf_size, 10, 25, 0.0,
        0, "test", &|_| {},
    );

    // BR value for each player should be >= 0 (can always fold for 0 in many spots)
    for hero_pos in 0..2u8 {
        let br = best_response_value(
            &tree, &layout, &solve_eq, &result.strategy_sum,
            0, 5, hero_pos,
        );
        assert!(br.is_finite(), "BR value should be finite, got {br}");
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p poker-solver-core postflop_bucketed::tests::best_response_value`
Expected: FAIL — function does not exist.

**Step 3: Implement `best_response_value()`**

Add after `eval_with_avg_strategy()` (~line 664):

```rust
/// Best-response tree traversal. Like `eval_with_avg_strategy` but at
/// decision nodes where `hero_pos` is the acting player, picks the action
/// with max value instead of mixing according to the average strategy.
///
/// Returns the expected value (in pot fractions) for `hero_pos` when playing
/// optimally against the opponent's average strategy, averaged uniformly
/// across all bucket pairs.
fn best_response_value(
    tree: &PostflopTree,
    layout: &PostflopLayout,
    solve_eq: &SolveEquity<'_>,
    strategy_sum: &[f64],
    node_idx: u32,
    num_buckets: usize,
    hero_pos: u8,
) -> f64 {
    let mut total = 0.0;
    let count = num_buckets * num_buckets;
    for hb in 0..num_buckets as u16 {
        for ob in 0..num_buckets as u16 {
            total += br_traverse(
                tree, layout, solve_eq, strategy_sum,
                node_idx, hb, ob, hero_pos,
            );
        }
    }
    if count == 0 { 0.0 } else { total / count as f64 }
}

/// Recursive best-response traversal for a single bucket pair.
fn br_traverse(
    tree: &PostflopTree,
    layout: &PostflopLayout,
    solve_eq: &SolveEquity<'_>,
    strategy_sum: &[f64],
    node_idx: u32,
    hero_bucket: u16,
    opp_bucket: u16,
    hero_pos: u8,
) -> f64 {
    match &tree.nodes[node_idx as usize] {
        PostflopNode::Terminal { terminal_type, pot_fraction } => {
            let current_street = layout.street(node_idx);
            let eq_table = solve_equity_for_street(solve_eq, current_street);
            postflop_terminal_value(
                *terminal_type, *pot_fraction,
                hero_bucket, opp_bucket, hero_pos, eq_table,
            )
        }
        PostflopNode::Chance { children, street, .. } => {
            let transition = match street {
                Street::Turn => solve_eq.flop_to_turn,
                Street::River => solve_eq.turn_to_river,
                _ => {
                    return children.iter()
                        .map(|&child| br_traverse(
                            tree, layout, solve_eq, strategy_sum,
                            child, hero_bucket, opp_bucket, hero_pos,
                        ))
                        .sum::<f64>() / children.len().max(1) as f64;
                }
            };
            debug_assert_eq!(children.len(), 1);
            let child = children[0];
            let num_new = transition[0].len();
            let mut value = 0.0;
            #[allow(clippy::cast_possible_truncation)]
            for new_hero in 0..num_new {
                let hw = transition[hero_bucket as usize][new_hero];
                if hw < 1e-12 { continue; }
                for new_opp in 0..num_new {
                    let ow = transition[opp_bucket as usize][new_opp];
                    if ow < 1e-12 { continue; }
                    value += hw * ow * br_traverse(
                        tree, layout, solve_eq, strategy_sum,
                        child, new_hero as u16, new_opp as u16, hero_pos,
                    );
                }
            }
            value
        }
        PostflopNode::Decision { position, children, .. } => {
            let is_hero = *position == hero_pos;
            let bucket = if is_hero { hero_bucket } else { opp_bucket };
            let (start, _) = layout.slot(node_idx, bucket);
            let num_actions = children.len();

            let strategy = normalize_strategy_sum(strategy_sum, start, num_actions);

            if is_hero {
                // Best response: pick the action with max value
                children.iter().enumerate()
                    .map(|(i, &child)| br_traverse(
                        tree, layout, solve_eq, strategy_sum,
                        child, hero_bucket, opp_bucket, hero_pos,
                    ))
                    .fold(f64::NEG_INFINITY, f64::max)
            } else {
                // Opponent plays average strategy
                children.iter().enumerate()
                    .map(|(i, &child)| {
                        strategy[i] * br_traverse(
                            tree, layout, solve_eq, strategy_sum,
                            child, hero_bucket, opp_bucket, hero_pos,
                        )
                    })
                    .sum()
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p poker-solver-core postflop_bucketed::tests::best_response_value`
Expected: PASS

**Step 5: Commit**

```
feat: add best_response_value() for postflop bucketed CFR
```

---

### Task 2: Add `postflop_exploitability()` and wire into bucketed solve loop

**Files:**
- Modify: `crates/core/src/preflop/postflop_bucketed.rs`
- Modify: `crates/core/src/preflop/postflop_abstraction.rs`

**Step 1: Write test for `postflop_exploitability`**

Add to `mod tests` in `postflop_bucketed.rs`:

```rust
#[timed_test]
fn postflop_exploitability_decreases_with_training() {
    let config = PostflopModelConfig::fast();
    let tree = PostflopTree::build_with_spr(&config, 3.5).unwrap();
    let streets = annotate_streets(&tree);
    let layout = PostflopLayout::build(&tree, &streets, 5, 5, 5);
    let buf_size = layout.total_size;

    let eq = BucketEquity {
        equity: vec![vec![0.5; 5]; 5],
        num_buckets: 5,
    };
    let f2t = identity_transition(5);
    let t2r = identity_transition(5);
    let solve_eq = SolveEquity {
        flop: &eq, turn: &eq, river: &eq,
        flop_to_turn: &f2t, turn_to_river: &t2r,
    };

    // Few iterations
    let early = solve_one_flop(
        &tree, &layout, &solve_eq,
        5, buf_size, 3, 25, 0.0,
        0, "test", &|_| {},
    );
    // Many iterations
    let late = solve_one_flop(
        &tree, &layout, &solve_eq,
        5, buf_size, 50, 25, 0.0,
        0, "test", &|_| {},
    );

    assert!(early.exploitability > late.exploitability,
        "exploitability should decrease: early={:.6}, late={:.6}",
        early.exploitability, late.exploitability);
    assert!(late.exploitability >= 0.0);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p poker-solver-core postflop_bucketed::tests::postflop_exploitability`
Expected: FAIL — `exploitability` field does not exist on `FlopSolveResult`.

**Step 3: Add `postflop_exploitability()` wrapper**

Add after `best_response_value()`:

```rust
/// Exploitability of the current average strategy in pot fractions.
///
/// Sums best-response values for both players across all bucket pairs.
/// At Nash equilibrium this is 0.
fn postflop_exploitability(
    tree: &PostflopTree,
    layout: &PostflopLayout,
    solve_eq: &SolveEquity<'_>,
    strategy_sum: &[f64],
    num_buckets: usize,
) -> f64 {
    let p0 = best_response_value(tree, layout, solve_eq, strategy_sum, 0, num_buckets, 0);
    let p1 = best_response_value(tree, layout, solve_eq, strategy_sum, 0, num_buckets, 1);
    (p0 + p1).max(0.0)
}
```

**Step 4: Update `FlopSolveResult`**

In `crates/core/src/preflop/postflop_abstraction.rs`, change:

```rust
// Old:
pub(crate) struct FlopSolveResult {
    pub strategy_sum: Vec<f64>,
    pub avg_regret: f64,
    pub iterations_used: usize,
}

// New:
pub(crate) struct FlopSolveResult {
    pub strategy_sum: Vec<f64>,
    pub exploitability: f64,
    pub iterations_used: usize,
}
```

**Step 5: Update `FlopStage::Solving`**

In `postflop_abstraction.rs`:

```rust
// Old:
Solving {
    iteration: usize,
    max_iterations: usize,
    avg_regret: f64,
},

// New:
Solving {
    iteration: usize,
    max_iterations: usize,
    exploitability: f64,
},
```

Update `Display` impl:

```rust
// Old:
FlopStage::Solving { iteration, max_iterations, avg_regret } =>
    write!(f, "Flop '{flop_name}' CFR +R={avg_regret:.4} ({iteration}/{max_iterations})"),

// New:
FlopStage::Solving { iteration, max_iterations, exploitability } =>
    write!(f, "Flop '{flop_name}' CFR expl={exploitability:.4} ({iteration}/{max_iterations})"),
```

**Step 6: Wire into `solve_one_flop()` loop**

Replace in `solve_one_flop()`:

```rust
// Old (line 319):
current_regret = avg_positive_regret_flat(&regret_sum, iteration);

// New:
let current_expl = postflop_exploitability(
    tree, layout, solve_eq, &strategy_sum, num_flop_buckets,
);
```

Update the `on_progress` call and early stop:

```rust
on_progress(BuildPhase::FlopProgress {
    flop_name: flop_name.to_string(),
    stage: FlopStage::Solving {
        iteration: iter + 1,
        max_iterations: num_iterations,
        exploitability: current_expl,
    },
});

if iter >= 1 && current_expl < regret_threshold {
    break;
}
```

Update the return:

```rust
FlopSolveResult { strategy_sum, exploitability: current_expl, iterations_used }
```

Remove the `current_regret` variable and the initial progress report's `avg_regret: 0.0` → `exploitability: 0.0`.

Rename `regret_threshold` parameter to `exploitability_threshold` in `solve_one_flop()` signature and early stop condition.

**Step 7: Fix all compile errors**

Update `build_phase_display_flop_progress` test in `postflop_abstraction.rs`:

```rust
// Old:
stage: FlopStage::Solving {
    iteration: 45,
    max_iterations: 200,
    avg_regret: 0.0032,
},

// New:
stage: FlopStage::Solving {
    iteration: 45,
    max_iterations: 200,
    exploitability: 0.0032,
},
```

Update assertion to check for `expl=` instead of `+R=`.

Update existing test `solve_one_flop_returns_result_struct`:
- Change `result.avg_regret.is_finite()` → `result.exploitability.is_finite()`

**Step 8: Run tests**

Run: `cargo test -p poker-solver-core postflop_bucketed`
Expected: PASS

**Step 9: Commit**

```
feat: replace avg regret with exploitability in bucketed per-flop CFR

Computes best-response value for both players to measure exploitability.
Early stopping triggers when exploitability drops below threshold.
```

---

### Task 3: Wire exploitability into MCCFR per-flop solve

**Files:**
- Modify: `crates/core/src/preflop/postflop_mccfr.rs`

**Step 1: Understand the difference**

The MCCFR variant uses concrete hands but indexes regrets/strategies by flop bucket. For exploitability, we need bucket-level BR computation. The MCCFR variant doesn't have `SolveEquity` tables — it uses `rank_hand()` for concrete hand evaluation.

For MCCFR, we cannot easily compute exact bucket-level exploitability without equity tables. The cleanest approach: keep `avg_positive_regret_flat()` as a proxy for the MCCFR variant, since it already works. The bucketed variant is the primary one that benefits from exploitability.

**However**, since both variants produce `FlopSolveResult` and share `FlopStage`, we need them both to populate the `exploitability` field. For MCCFR, report `avg_positive_regret_flat()` as the `exploitability` value (it's a loose upper bound on exploitability and serves the same convergence role).

**Step 2: Update `mccfr_solve_one_flop()`**

Replace `current_regret` with `current_expl`:

```rust
// Old:
current_regret = avg_positive_regret_flat(&regret_sum, iteration);
// ...
avg_regret: current_regret,
// ...
FlopSolveResult { strategy_sum, avg_regret: current_regret, iterations_used }

// New:
let current_expl = avg_positive_regret_flat(&regret_sum, iteration);
// ...
exploitability: current_expl,
// ...
FlopSolveResult { strategy_sum, exploitability: current_expl, iterations_used }
```

Rename `regret_threshold` parameter to `exploitability_threshold` in `mccfr_solve_one_flop()` signature and early stop condition.

**Step 3: Run tests**

Run: `cargo test -p poker-solver-core postflop_mccfr`
Expected: PASS

**Step 4: Commit**

```
refactor: update MCCFR per-flop solve to use exploitability field naming
```

---

### Task 4: Rename config field and update callers

**Files:**
- Modify: `crates/core/src/preflop/postflop_model.rs` (~line 123)
- Modify: `crates/core/src/preflop/postflop_bucketed.rs` (callers ~line 97, 181)
- Modify: `crates/core/src/preflop/postflop_mccfr.rs` (caller ~line 162)
- Modify: `sample_configurations/preflop_medium.yaml`
- Modify: `docs/training.md`

**Step 1: Rename config field**

In `postflop_model.rs`:

```rust
// Old:
fn default_cfr_regret_threshold() -> f64 { 0.001 }
// ...
#[serde(default = "default_cfr_regret_threshold", alias = "cfr_delta_threshold")]
pub cfr_regret_threshold: f64,

// New:
fn default_cfr_exploitability_threshold() -> f64 { 0.01 }
// ...
#[serde(default = "default_cfr_exploitability_threshold", alias = "cfr_regret_threshold", alias = "cfr_delta_threshold")]
pub cfr_exploitability_threshold: f64,
```

**Step 2: Update all callers**

In `postflop_bucketed.rs`, replace `config.cfr_regret_threshold` → `config.cfr_exploitability_threshold` (2 call sites ~lines 97, 181).

In `postflop_mccfr.rs`, replace `config.cfr_regret_threshold` → `config.cfr_exploitability_threshold` (1 call site ~line 162).

Update `PostflopModelConfig` presets (e.g. `fast()`, `medium()`, etc.) and test defaults.

In MCCFR test (~line 772): `cfr_regret_threshold: 0.001` → `cfr_exploitability_threshold: 0.01`.

**Step 3: Update YAML configs**

In `sample_configurations/preflop_medium.yaml`, the postflop model section doesn't have this field explicitly — it uses the default. No YAML change needed unless it's present. Check other sample configs for `cfr_regret_threshold` or `cfr_delta_threshold` and rename to `cfr_exploitability_threshold`.

**Step 4: Update `docs/training.md`**

Find references to `cfr_regret_threshold` and update:

```
| `cfr_exploitability_threshold` | 0.01 | f64 | Exploitability threshold for early per-flop CFR stopping (pot fraction) |
```

Note that `cfr_regret_threshold` and `cfr_delta_threshold` still work as serde aliases.

**Step 5: Verify**

Run: `cargo build -p poker-solver-core && cargo test -p poker-solver-core`
Expected: Compiles, all tests pass.

**Step 6: Commit**

```
refactor: rename cfr_regret_threshold to cfr_exploitability_threshold

Default changed from 0.001 to 0.01 (pot fraction units). Serde aliases
preserve backward compatibility with existing configs.
```

---

### Task 5: Clean up dead code

**Files:**
- Modify: `crates/core/src/preflop/postflop_abstraction.rs`
- Modify: `crates/core/src/preflop/postflop_mccfr.rs`

**Step 1: Check if `avg_positive_regret_flat` is still used**

The MCCFR variant still uses it as a proxy. If so, keep it. If the bucketed variant no longer imports it, remove that import.

**Step 2: Remove unused imports**

In `postflop_bucketed.rs`, remove import of `avg_positive_regret_flat` if no longer used.

**Step 3: Run clippy**

Run: `cargo clippy -p poker-solver-core`
Expected: No new warnings.

**Step 4: Commit**

```
refactor: remove unused avg_positive_regret_flat import from bucketed CFR
```

---

## Scope Notes

**In scope:**
- Bucketed CFR exploitability via best-response traversal
- MCCFR continues using avg positive regret as proxy (populating exploitability field)
- Config rename with backward-compat aliases
- Updated progress reporting

**Out of scope:**
- True MCCFR exploitability (would require equity tables or massive sampling)
- Parallelizing the BR traversal (can be added later if needed)
- Changing the preflop solver's exploitability (already has its own)
