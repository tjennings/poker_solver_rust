//! Best-response exploitability computation for preflop strategies.
//!
//! Exploitability measures how much a best-response opponent can exploit
//! a given strategy. At Nash equilibrium, exploitability is zero.
//!
//! The algorithm computes, for each player:
//!   1. A forward pass propagating opponent reach probabilities through the tree
//!   2. At hero decision nodes, pick the action maximizing expected value
//!   3. At opponent nodes, weight by opponent's average strategy
//!   4. At terminals, sum weighted utilities across all opponent hands
//!
//! `Exploitability = (BR_value_p0 + BR_value_p1) / (2 * total_weight)`

use super::equity::EquityTable;
use super::solver::{postflop_showdown_value, terminal_value, PostflopState, PreflopStrategy};
use super::tree::{PreflopNode, PreflopTree, TerminalType};

const NUM_HANDS: usize = 169;

/// Compute exploitability of a preflop strategy.
///
/// Returns exploitability per hand in SB chip units (SB=1, BB=2).
/// Multiply by 500 to convert to mBB/hand.
/// A value of 0 means the strategy is a Nash equilibrium.
pub(crate) fn compute_exploitability(
    tree: &PreflopTree,
    strategy: &PreflopStrategy,
    equity: &EquityTable,
    investments: &[[u32; 2]],
    postflop: Option<&PostflopState>,
) -> f64 {
    let total_weight: f64 = (0..NUM_HANDS)
        .flat_map(|h1| (0..NUM_HANDS).map(move |h2| (h1, h2)))
        .map(|(h1, h2)| equity.weight(h1, h2))
        .sum();

    if total_weight == 0.0 {
        return 0.0;
    }

    let mut total_br = 0.0;
    for hero_pos in 0..2u8 {
        for hh in 0..NUM_HANDS {
            let opp_reach = [1.0f64; NUM_HANDS];
            #[allow(clippy::cast_possible_truncation)]
            let hh_u16 = hh as u16; // Safe: hh < 169, well within u16
            total_br += br_traverse(
                tree, strategy, equity, investments, postflop, 0, hh_u16, hero_pos, &opp_reach,
            );
        }
    }

    total_br / (2.0 * total_weight)
}

/// Recursive best-response traversal for a single hero hand.
///
/// At each node, `opp_reach[oh]` is the probability of reaching this node
/// when the opponent holds hand `oh`, given the opponent plays average strategy.
///
/// Returns the best-response value (weighted by opponent reach and hand weights).
#[allow(clippy::too_many_arguments)]
fn br_traverse(
    tree: &PreflopTree,
    strategy: &PreflopStrategy,
    equity: &EquityTable,
    investments: &[[u32; 2]],
    postflop: Option<&PostflopState>,
    node_idx: u32,
    hero_hand: u16,
    hero_pos: u8,
    opp_reach: &[f64; NUM_HANDS],
) -> f64 {
    let inv = investments[node_idx as usize];
    let hero_inv = f64::from(inv[hero_pos as usize]);

    match &tree.nodes[node_idx as usize] {
        PreflopNode::Terminal { terminal_type, pot } => terminal_br_value(
            *terminal_type,
            *pot,
            hero_inv,
            hero_hand,
            hero_pos,
            opp_reach,
            equity,
            postflop,
            node_idx,
        ),
        PreflopNode::Decision {
            position, children, ..
        } => {
            if *position == hero_pos {
                // Hero picks the action that maximizes expected value.
                children
                    .iter()
                    .map(|&child| {
                        br_traverse(
                            tree, strategy, equity, investments, postflop, child, hero_hand,
                            hero_pos, opp_reach,
                        )
                    })
                    .fold(f64::NEG_INFINITY, f64::max)
            } else {
                // Opponent plays average strategy — split reach by action probabilities.
                opponent_br_value(
                    tree, strategy, equity, investments, postflop, node_idx, hero_hand, hero_pos,
                    opp_reach, children,
                )
            }
        }
    }
}

/// Compute BR value at an opponent decision node by splitting reach.
#[allow(clippy::too_many_arguments)]
fn opponent_br_value(
    tree: &PreflopTree,
    strategy: &PreflopStrategy,
    equity: &EquityTable,
    investments: &[[u32; 2]],
    postflop: Option<&PostflopState>,
    node_idx: u32,
    hero_hand: u16,
    hero_pos: u8,
    opp_reach: &[f64; NUM_HANDS],
    children: &[u32],
) -> f64 {
    let mut value = 0.0;
    for (a, &child) in children.iter().enumerate() {
        let mut child_reach = [0.0f64; NUM_HANDS];
        let mut any_reach = false;
        for (oh, reach) in opp_reach.iter().enumerate() {
            if *reach == 0.0 {
                continue;
            }
            let probs = strategy.get_probs(node_idx, oh);
            if a < probs.len() {
                child_reach[oh] = reach * probs[a];
                if child_reach[oh] > 0.0 {
                    any_reach = true;
                }
            }
        }
        if !any_reach {
            continue;
        }
        value += br_traverse(
            tree, strategy, equity, investments, postflop, child, hero_hand, hero_pos,
            &child_reach,
        );
    }
    value
}

/// Compute hero's BR value at a terminal node, summed over all opponent hands.
#[allow(clippy::too_many_arguments, clippy::cast_possible_truncation)]
fn terminal_br_value(
    terminal_type: TerminalType,
    pot: u32,
    hero_inv: f64,
    hero_hand: u16,
    hero_pos: u8,
    opp_reach: &[f64; NUM_HANDS],
    equity: &EquityTable,
    postflop: Option<&PostflopState>,
    node_idx: u32,
) -> f64 {
    let mut value = 0.0;
    for (oh, &reach) in opp_reach.iter().enumerate() {
        if reach == 0.0 {
            continue;
        }
        // Map to positional (h1=position0, h2=position1).
        // Safe: oh < 169, well within u16.
        let oh_u16 = oh as u16;
        let (h1, h2) = if hero_pos == 0 {
            (hero_hand, oh_u16)
        } else {
            (oh_u16, hero_hand)
        };
        let w = equity.weight(h1 as usize, h2 as usize);
        if w == 0.0 {
            continue;
        }

        let util = match terminal_type {
            TerminalType::Showdown => {
                if let Some(pf) = postflop {
                    postflop_showdown_value(pf, node_idx, pot, hero_inv, hero_hand, oh_u16, hero_pos)
                } else {
                    terminal_value(terminal_type, pot, hero_inv, hero_hand, oh_u16, hero_pos, equity)
                }
            }
            TerminalType::Fold { .. } => {
                terminal_value(terminal_type, pot, hero_inv, hero_hand, oh_u16, hero_pos, equity)
            }
        };

        value += reach * w * util;
    }
    value
}

#[cfg(test)]
mod tests {
    use crate::preflop::config::PreflopConfig;
    use crate::preflop::solver::PreflopSolver;
    use test_macros::timed_test;

    fn tiny_config() -> PreflopConfig {
        let mut config = PreflopConfig::heads_up(3);
        config.raise_sizes = vec![vec![3.0]];
        config.raise_cap = 1;
        config
    }

    #[timed_test]
    fn exploitability_is_non_negative() {
        let config = tiny_config();
        let mut solver = PreflopSolver::new(&config);
        solver.train(10);
        let expl = solver.exploitability();
        assert!(
            expl >= 0.0,
            "exploitability must be non-negative, got {expl}"
        );
    }

    #[timed_test]
    fn uniform_strategy_has_positive_exploitability() {
        let config = tiny_config();
        let solver = PreflopSolver::new(&config);
        // No training — strategy is uniform
        let expl = solver.exploitability();
        assert!(
            expl > 0.0,
            "uniform strategy should be exploitable, got {expl}"
        );
    }

    #[timed_test(15)]
    fn trained_strategy_has_lower_exploitability() {
        let config = tiny_config();

        let untrained = PreflopSolver::new(&config);
        let uniform_expl = untrained.exploitability();

        let mut trained = PreflopSolver::new(&config);
        trained.train(100);
        let trained_expl = trained.exploitability();

        assert!(
            trained_expl < uniform_expl,
            "trained exploitability ({trained_expl:.6}) should be less than \
             uniform ({uniform_expl:.6})"
        );
    }

    #[timed_test(15)]
    fn exploitability_decreases_with_more_training() {
        let config = tiny_config();
        let mut solver = PreflopSolver::new(&config);

        solver.train(50);
        let expl_50 = solver.exploitability();

        solver.train(100);
        let expl_150 = solver.exploitability();

        assert!(
            expl_150 < expl_50,
            "exploitability should decrease: 50 iters={expl_50:.6}, 150 iters={expl_150:.6}"
        );
    }
}
