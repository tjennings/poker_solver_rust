//! Sampled exploitability calculation for Limit Hold'em.
//!
//! Computes a best-response value for each player by walking the full game tree:
//! - At **BR player** nodes: try all actions, pick the one with max EV.
//! - At **opponent** nodes: query the strategy NN, weight EVs by action probabilities.
//! - At **terminal** nodes: return the game utility.
//!
//! Exploitability = `(BR_p1_EV + BR_p2_EV) / 2`, reported in milli-big-bets per hand.

use poker_solver_core::game::{Game, Player};

use crate::SdCfrError;
use crate::eval::ExplicitPolicy;
use crate::traverse::StateEncoder;

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/// Compute sampled exploitability in milli-big-bets per hand (mbb/h).
///
/// For each player as the best-response player, traverses the game tree
/// across all provided deals, computing the maximum achievable EV against
/// the opponent's fixed NN strategy. The result is the average of both
/// players' BR values, scaled to mbb/h.
pub fn sampled_exploitability<G, E>(
    game: &G,
    encoder: &E,
    policies: &[ExplicitPolicy; 2],
    deals: &[G::State],
    num_actions: usize,
) -> Result<f64, SdCfrError>
where
    G: Game,
    E: StateEncoder<G::State>,
{
    if deals.is_empty() {
        return Ok(0.0);
    }

    let br_p1_ev = average_br_ev(game, encoder, policies, deals, Player::Player1, num_actions)?;
    let br_p2_ev = average_br_ev(game, encoder, policies, deals, Player::Player2, num_actions)?;
    let exploitability = (br_p1_ev + br_p2_ev) / 2.0;
    Ok(exploitability * 1000.0)
}

// ---------------------------------------------------------------------------
// Internal: per-player BR EV
// ---------------------------------------------------------------------------

/// Average best-response EV for one player across all deals.
fn average_br_ev<G, E>(
    game: &G,
    encoder: &E,
    policies: &[ExplicitPolicy; 2],
    deals: &[G::State],
    br_player: Player,
    num_actions: usize,
) -> Result<f64, SdCfrError>
where
    G: Game,
    E: StateEncoder<G::State>,
{
    let total: f64 = deals
        .iter()
        .map(|deal| br_traverse(game, encoder, policies, deal, br_player, num_actions))
        .collect::<Result<Vec<f64>, SdCfrError>>()?
        .iter()
        .sum();
    Ok(total / deals.len() as f64)
}

// ---------------------------------------------------------------------------
// Internal: recursive best-response traversal
// ---------------------------------------------------------------------------

/// Recursive best-response traversal from a single state.
///
/// - Terminal: return utility for `br_player`.
/// - BR player's turn: try all actions, return max EV.
/// - Opponent's turn: weight child EVs by strategy probabilities.
fn br_traverse<G, E>(
    game: &G,
    encoder: &E,
    policies: &[ExplicitPolicy; 2],
    state: &G::State,
    br_player: Player,
    num_actions: usize,
) -> Result<f64, SdCfrError>
where
    G: Game,
    E: StateEncoder<G::State>,
{
    if game.is_terminal(state) {
        return Ok(game.utility(state, br_player));
    }

    let current = game.player(state);
    let actions = game.actions(state);

    if current == br_player {
        best_response_value(
            game,
            encoder,
            policies,
            state,
            br_player,
            &actions,
            num_actions,
        )
    } else {
        opponent_weighted_value(
            game,
            encoder,
            policies,
            state,
            br_player,
            &actions,
            num_actions,
        )
    }
}

/// At a BR player node, try all actions and return the maximum EV.
fn best_response_value<G, E>(
    game: &G,
    encoder: &E,
    policies: &[ExplicitPolicy; 2],
    state: &G::State,
    br_player: Player,
    actions: &[poker_solver_core::game::Action],
    num_actions: usize,
) -> Result<f64, SdCfrError>
where
    G: Game,
    E: StateEncoder<G::State>,
{
    let mut best = f64::NEG_INFINITY;
    for &action in actions {
        let next = game.next_state(state, action);
        let ev = br_traverse(game, encoder, policies, &next, br_player, num_actions)?;
        if ev > best {
            best = ev;
        }
    }
    Ok(best)
}

/// At an opponent node, compute the strategy-weighted average EV.
fn opponent_weighted_value<G, E>(
    game: &G,
    encoder: &E,
    policies: &[ExplicitPolicy; 2],
    state: &G::State,
    br_player: Player,
    actions: &[poker_solver_core::game::Action],
    num_actions: usize,
) -> Result<f64, SdCfrError>
where
    G: Game,
    E: StateEncoder<G::State>,
{
    let opponent = br_player.opponent();
    let pi = player_index(opponent);
    let features = encoder.encode(state, opponent);
    let probs = policies[pi].strategy(&features)?;

    let mut weighted_ev = 0.0;
    for (i, &action) in actions.iter().enumerate() {
        let prob = action_probability(&probs, i, num_actions);
        if prob > 1e-8 {
            let next = game.next_state(state, action);
            let ev = br_traverse(game, encoder, policies, &next, br_player, num_actions)?;
            weighted_ev += prob * ev;
        }
    }
    Ok(weighted_ev)
}

/// Extract action probability from the NN output, handling mismatched sizes.
fn action_probability(probs: &[f32], action_idx: usize, _num_actions: usize) -> f64 {
    if action_idx < probs.len() {
        f64::from(probs[action_idx])
    } else {
        0.0
    }
}

/// Map Player enum to array index.
const fn player_index(player: Player) -> usize {
    match player {
        Player::Player1 => 0,
        Player::Player2 => 1,
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use crate::card_features::{BET_FEATURES, InfoSetFeatures};
    use crate::model_buffer::ModelBuffer;
    use candle_core::{DType, Device};
    use candle_nn::{VarBuilder, VarMap};
    use poker_solver_core::game::{KuhnPoker, LimitHoldem, LimitHoldemConfig};

    use crate::network::AdvantageNet;

    // -----------------------------------------------------------------------
    // Kuhn encoder (minimal encoder for testing)
    // -----------------------------------------------------------------------

    struct KuhnEncoder {
        game: KuhnPoker,
    }

    impl KuhnEncoder {
        fn new() -> Self {
            Self {
                game: KuhnPoker::new(),
            }
        }
    }

    impl StateEncoder<<KuhnPoker as Game>::State> for KuhnEncoder {
        fn encode(&self, state: &<KuhnPoker as Game>::State, _player: Player) -> InfoSetFeatures {
            use poker_solver_core::info_key::InfoKey;

            let key = self.game.info_set_key(state);
            let hand_bits = InfoKey::from_raw(key).hand_bits();
            let card_value = hand_bits as i8;

            let mut cards = [-1i8; 7];
            cards[0] = card_value;

            InfoSetFeatures {
                cards,
                bets: [0.0f32; BET_FEATURES],
            }
        }
    }

    /// Create a ModelBuffer with `n` entries.
    fn make_buffer(n: u32, num_actions: usize, hidden_dim: usize) -> ModelBuffer {
        let mut buf = ModelBuffer::new();
        for i in 1..=n {
            let varmap = VarMap::new();
            let vs = VarBuilder::from_varmap(&varmap, DType::F32, &Device::Cpu);
            let _net = AdvantageNet::new(num_actions, hidden_dim, &vs).unwrap();
            buf.push(&varmap, i).unwrap();
        }
        buf
    }

    // -----------------------------------------------------------------------
    // 1. Exploitability returns finite value for Kuhn poker
    // -----------------------------------------------------------------------

    #[test]
    fn exploitability_returns_finite_for_kuhn() {
        let game = KuhnPoker::new();
        let encoder = KuhnEncoder::new();
        let num_actions = 2;
        let hidden_dim = 16;

        let buf = make_buffer(3, num_actions, hidden_dim);
        let policies = [
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
        ];

        let deals = game.initial_states();
        let result = sampled_exploitability(&game, &encoder, &policies, &deals, num_actions);

        assert!(result.is_ok(), "exploitability should not error");
        let mbb = result.unwrap();
        assert!(
            mbb.is_finite(),
            "exploitability should be finite, got {mbb}"
        );
    }

    // -----------------------------------------------------------------------
    // 2. Exploitability is non-negative
    // -----------------------------------------------------------------------

    #[test]
    fn exploitability_is_non_negative() {
        let game = KuhnPoker::new();
        let encoder = KuhnEncoder::new();
        let num_actions = 2;
        let hidden_dim = 16;

        let buf = make_buffer(3, num_actions, hidden_dim);
        let policies = [
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
        ];

        let deals = game.initial_states();
        let mbb = sampled_exploitability(&game, &encoder, &policies, &deals, num_actions).unwrap();

        assert!(mbb >= 0.0, "exploitability must be non-negative, got {mbb}");
    }

    // -----------------------------------------------------------------------
    // 3. Empty deals returns zero
    // -----------------------------------------------------------------------

    #[test]
    fn empty_deals_returns_zero() {
        let game = KuhnPoker::new();
        let encoder = KuhnEncoder::new();
        let num_actions = 2;
        let hidden_dim = 16;

        let buf = make_buffer(1, num_actions, hidden_dim);
        let policies = [
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
        ];

        let empty: Vec<<KuhnPoker as Game>::State> = vec![];
        let mbb = sampled_exploitability(&game, &encoder, &policies, &empty, num_actions).unwrap();

        assert!(
            (mbb - 0.0).abs() < f64::EPSILON,
            "empty deals should return 0 exploitability"
        );
    }

    // -----------------------------------------------------------------------
    // 4. BR traverse at terminal returns utility
    // -----------------------------------------------------------------------

    #[test]
    fn br_traverse_terminal_returns_utility() {
        let game = KuhnPoker::new();
        let encoder = KuhnEncoder::new();
        let num_actions = 2;
        let hidden_dim = 16;

        let buf = make_buffer(1, num_actions, hidden_dim);
        let policies = [
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
        ];

        // Navigate Kuhn to a terminal state: P1 checks, P2 checks (showdown)
        let deals = game.initial_states();
        let deal = &deals[0];
        use poker_solver_core::game::Action;
        let after_check = game.next_state(deal, Action::Check);
        let terminal = game.next_state(&after_check, Action::Check);
        assert!(game.is_terminal(&terminal));

        let util_p1 = game.utility(&terminal, Player::Player1);
        let br_val = br_traverse(
            &game,
            &encoder,
            &policies,
            &terminal,
            Player::Player1,
            num_actions,
        )
        .unwrap();
        assert!(
            (br_val - util_p1).abs() < f64::EPSILON,
            "BR at terminal should equal utility: br={br_val}, util={util_p1}"
        );
    }

    // -----------------------------------------------------------------------
    // 5. Exploitability works for LHE game
    // -----------------------------------------------------------------------

    #[test]
    fn exploitability_works_for_lhe() {
        let config = LimitHoldemConfig {
            stack_depth: 5,
            num_streets: 2, // Flop HE only (smaller tree)
            ..Default::default()
        };
        let game = LimitHoldem::new(config, 5, 42);
        let encoder = crate::lhe_encoder::LheEncoder::new();
        let num_actions = 3; // fold/call/raise or check/bet
        let hidden_dim = 16;

        let buf = make_buffer(2, num_actions, hidden_dim);
        let policies = [
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
        ];

        let deals = game.initial_states();
        let result = sampled_exploitability(&game, &encoder, &policies, &deals, num_actions);

        assert!(result.is_ok(), "LHE exploitability should not error");
        let mbb = result.unwrap();
        assert!(
            mbb.is_finite(),
            "LHE exploitability should be finite, got {mbb}"
        );
        assert!(
            mbb >= 0.0,
            "LHE exploitability must be non-negative, got {mbb}"
        );
    }

    // -----------------------------------------------------------------------
    // 6. BR at a single non-terminal returns a finite value
    // -----------------------------------------------------------------------

    #[test]
    fn br_traverse_non_terminal_returns_finite() {
        let game = KuhnPoker::new();
        let encoder = KuhnEncoder::new();
        let num_actions = 2;
        let hidden_dim = 16;

        let buf = make_buffer(1, num_actions, hidden_dim);
        let policies = [
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
            ExplicitPolicy::from_buffer(&buf, num_actions, hidden_dim, &Device::Cpu).unwrap(),
        ];

        let deals = game.initial_states();
        let deal = &deals[0];

        let ev = br_traverse(
            &game,
            &encoder,
            &policies,
            deal,
            Player::Player1,
            num_actions,
        )
        .unwrap();
        assert!(
            ev.is_finite(),
            "BR at non-terminal should be finite, got {ev}"
        );
    }

    // -----------------------------------------------------------------------
    // 7. ModelBuffer save/load round-trip
    // -----------------------------------------------------------------------

    #[test]
    fn model_buffer_save_load_round_trip() {
        let num_actions = 3;
        let hidden_dim = 16;
        let buf = make_buffer(3, num_actions, hidden_dim);

        let dir = std::env::temp_dir().join("test_model_buffer_save_load");
        std::fs::create_dir_all(&dir).unwrap();
        let path = dir.join("test_buffer.bin");

        buf.save_to_file(&path).unwrap();
        let loaded = ModelBuffer::load_from_file(&path).unwrap();

        assert_eq!(loaded.len(), buf.len());
        assert!((loaded.total_weight() - buf.total_weight()).abs() < 1e-10);

        // Verify loaded nets produce identical output
        for i in 0..buf.len() {
            assert_eq!(loaded.entry_iteration(i), buf.entry_iteration(i));
        }

        std::fs::remove_dir_all(&dir).unwrap();
    }
}
